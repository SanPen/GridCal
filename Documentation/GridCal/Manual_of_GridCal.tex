%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  My documentation report
%  Objetive: Explain what I did and how, so someone can continue with the investigation
%
% Important note:
% Chapter heading images should have a 2:1 width:height ratio,
% e.g. 920px width and 460px height.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,fleqn]{book} % Default font size and left-justified equations

\usepackage[top=3cm,bottom=3cm,left=3.2cm,right=3.2cm,headsep=10pt,letterpaper]{geometry} % Page margins

\usepackage{xcolor,lipsum} % Required for specifying colors by name
\definecolor{ocre}{RGB}{73,73,73} 
\definecolor{lightgray}{RGB}{229,229,229} 
% Font Settings
\usepackage{avant} % Use the Avantgarde font for headings
%\usepackage{times} % Use the Times font for headings
\usepackage{mathptmx} % Use the Adobe Times Roman as the default text font together with math symbols from the Sym­bol, Chancery and Com­puter Modern fonts

\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage[utf8]{inputenc} % Required for including letters with accents
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs


% MATHS PACKAGE
\usepackage{amsmath,tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{calc}
\usetikzlibrary{shapes}
\usetikzlibrary{backgrounds,fit,shapes}
\usetikzlibrary{positioning}
\usepackage{relsize}

\newcommand*{\horzbar}{\rule[0.05ex]{2.5ex}{0.5pt}}
\usepackage{calc}

% VERBATIM PACKAGE
\usepackage{verbatim}

% Bibliography
%\usepackage[style=alphabetic,sorting=nyt,sortcites=true,autopunct=true,babel=hyphen,hyperref=true,abbreviate=false,backref=true,backend=biber]{ieeetran}

%\addbibresource{bibliography.bib} % BibTeX bibliography file
%\defbibheading{bibempty}{}

\input{structure} % Insert the commands.tex file which contains the majority of the structure behind the template

\begin{document}

\let\cleardoublepage\clearpage

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begingroup
\thispagestyle{empty}

\AddToShipoutPicture*{\put(0,0){\includegraphics[scale=4.2]{frontpage}}} % Image background

\begin{tikzpicture}[remember picture, overlay]
\node[fill=white, fill opacity=0.6, anchor=north,minimum height=6cm, minimum width=\paperwidth] (names) at ([yshift=19cm]current page.south){};
\node[font=\normalfont\fontsize{35}{35}\sffamily\selectfont] at ([yshift=17cm]current page.south) {GridCal};
\node[font=\normalfont\fontsize{35}{35}\sffamily\selectfont \Huge] at ([yshift=15cm]current page.south) {Santiago Peñate Vera};
\end{tikzpicture}



%\centering
%%\vspace{5cm}
%\par\normalfont\fontsize{35}{35}\sffamily\selectfont
%\textbf{GridCal Manual }\\
%{\LARGE }\par % Book title
%\vspace*{1cm}
%{\Huge Santiago Peñate Vera}\par % Author name
%\endgroup

%----------------------------------------------------------------------------------------
%	COPYRIGHT PAGE
%----------------------------------------------------------------------------------------

\newpage
~\vfill
\thispagestyle{empty}

%\noindent Copyright \copyright\ 2014 Andrea Hidalgo\\ % Copyright notice

\noindent \textsc{GridCal}\\

\noindent Research oriented power systems software.\\ % License information

\noindent \textit{Started writing this document in Madrid the 9th of October of 2016} % Printing/edition date

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % heading image

\pagestyle{empty} % No headers

\renewcommand\contentsname{Table of content}
%\renewcommand{\bibname}{Bibliography}
\tableofcontents% Print the table of contents itself

%\cleardoublepage % Forces the first chapter to start on an odd page so it's on the right

\pagestyle{fancy} % Print headers again

%----------------------------------------------------------------------------------------
%	CHAPTER 1
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % Chapter heading image

\chapter{Introduction}

GridCal is a research oriented power systems software.  \newline

Research oriented? How? Well, it is a fruit of research. It is designed to be modular. As a researcher I found that the available software (not even talking about commercial options) are hard to expand or adapt to achieve complex simulations. GridCal is designed to allow you to build and reuse modules, which eventually will boost your productivity and the possibilities that are at hand. \newline

I have made other projects (even another open source one: fPotencia in C++). I believe that this project encapsulates my half life of programming experience and the curiosity I have developed for power systems. \newline

So, I do really hope you enjoy it, and if you have comments, suggestions or just want to collaborate, do not hesitate to contact.\newline

\begin{flushright}
	Cheers, 

Santiago
\end{flushright}


%----------------------------------------------------------------------------------------
%	CHAPTER 2
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % Chapter heading image
\chapter{Structure}

GridCal uses an object oriented approach for all the data and simulation management. However the object orientation is very inefficient when used in numerical computation, that is why there are \verb|compile()| functions that extract the information out of the objects and turn this information into vectors, matrices and DataFrames in order to have efficient numerical computations. I have found this approach to be the best compromise between efficientcy and code escalability and maintainability after having been involved in quite some number-crunching software developments.

The whole idea can be summarized as:

\begin{verbatim}
Object oriented structures -> intermediate objects holding arrays -> Numerical modules
\end{verbatim}




\section{Circuit and MultiCircuit}

The concept of circuit should be easy enough to understand. It represents a set of nodes (buses) and branches (lines, transformers or other impedances)


The \verb|MultiCircuit| class is the main object in GridCal. It represents a circuit that may contain islands. It is important to understand that a circuit split in two or more islands cannot be simulated as is, because the admittance matrix would be singular. The solution to this is to split the circuit in island-circuits. Therefore \verb|MultiCircuit| identifies the islands and creates individual \verb|Circuit| objects for each of them.

As I said before GridCal uses an object oriented approach for the data management. This allows to group the data in a smart way. In GridCal I have decided to have only two types of object directly declared in a \verb|Circuit| or \verb|MultiCircuit| object. These are the \verb|Bus| and the \verb|Branch|. The branches connect the buses and the buses contain all the other possible devices like loads, generators, batteries, etc. This simplifies enormously the management of element when adding, associating and deleting.

\subsection{Circuit}

\begin{itemize}
	\item $Ibase$: Base current to compute the per unit current values (kA)
	\item $Sbase$: Base power to compute the per unit power values (MVA)
	\item $branch\_original\_idx$: Array that keeps the index of the branches in the parent MultiCircuit object.
	\item $branches$: List of Branch objects.
	\item $bus\_original\_idx$: Array that keeps the index of the buses in the parent MultiCircuit object.
	\item $buses$: List of Bus objects.
	\item $graph$: Graph object from the \verb|networkx| package.
	\item $mc\_time\_series$
	\item $monte\_carlo\_input$
	\item $name$: Name of the circuit.
	\item $power\_flow\_input$
	\item $power\_flow\_results$
	\item $time\_series\_input$
	\item $time\_series\_results$
\end{itemize}


\subsection{MultiCircuit (inherits Circuit)}

Since the MultiCircuit inherits the Circuit object, it means that it has by default all the properties of the Circuit plus the ones that are below.

\begin{itemize}
	\item $branch\_dictionary$
	\item $branch\_names$: Array with the name of the branch objects all together.
	\item $bus\_dictionary$
	\item $bus\_names$: Array with the name of the bus objects all together.
	\item $circuits$: List of the Circuit objects. Each Circuit represents an island.
	\item $has\_time\_series$: Are there time series available? (True/False)
\end{itemize}


\section{Bus object}

The Bus object is the container of all the possible devices that can be attached to a bus bar or substation. Such objects can be loads, voltage controlled generators, static generators, batteries, shunt elements, etc.

\begin{itemize}
	\item $Qmax\_sum$: Maximum reactive power of this bus (inferred from the devices).
	\item $Qmin\_sum$: Minimum reactive power of this bus (inferred from the devices).
	\item $Vmax$: Maximum voltage of this bus (p.u.)
	\item $Vmin$: Minimum voltage of this bus (p.u.)
	\item $Vnom$: Nominal voltage of the bus (kV)
	\item $batteries$: List of Battery objects.
	\item $controlled\_generators$: List of ControlledGenerator objects.
	\item $dispatch\_storage$: Shall this bus dispatch its storage devices?  (True / False)
	\item $graphic\_object$: Qt graphic object associated to this bus.
	\item $is\_enabled$: Is this bus enabled for calculation? (True / False)
	\item $is\_slack$: Is this bus a slack bus? (True / False)
	\item $loads$: List of Load objects.
	\item $name$: Name of the element.
	\item $shunts$: List of Shunt objects.
	\item $static\_generators$: List of StaticGenerator objects.
	\item $type$: Type of the bus.
	\item $x$: x coordinate of the bus for representation.
	\item $y$: y coordinate of the bus for representation.
\end{itemize}


\subsection{Load object}

The load object implements the so-called ZIP model, in which the load can be represented by a combination of power (P), current(I), and impedance (Z).

\begin{itemize}
	\item $I$: Current (complex, in kA)
	\item $Iprof$: Pandas DataFrame with the current profile (complex, in kA)
	\item $S$: Power (complex in MVA)
	\item $Sprof$: Pandas DataFrame with the power profile (complex, in MVA)
	\item $Z$: Impedance (complex, in Ohm)
	\item $Zprof$: Pandas DataFrame with the impedance profile (complex, in Ohm)
	\item $name$: Name of the load.
\end{itemize}

The sign convention is: Positive to act as a load, negative to act as a generator.

\subsection{StaticGenerator object}

\begin{itemize}
	\item $S$
	\item $Sprof$
	\item $name$
\end{itemize}




\subsection{Battery object}

\begin{itemize}
	\item $Enom$
	\item $P$
	\item $Pprof$
	\item $Qmax$
	\item $Qmin$
	\item $Snom$
	\item $Vset$
	\item $Vset\_prof$
	\item $name$
\end{itemize}



\subsection{ControlledGenerator object}

\begin{itemize}
	\item $P$
	\item $Pprof$
	\item $Qmax$
	\item $Qmin$
	\item $Snom$
	\item $Vset$
	\item $Vset\_prof$
	\item $name$
\end{itemize}



\subsection{Shunt object}

\begin{itemize}
	\item $Y$
	\item $Yprof$
	\item $name$
\end{itemize}



\section{Branch object}


\begin{itemize}
	\item $angle$
	\item $bus_from$
	\item $is\_enabled$
	\item $mttf$
	\item $mttr$
	\item $name$
	\item $rate$
	\item $tap\_module$
	\item $y\_shunt$
	\item $z\_series$
\end{itemize}



\section{Line object (Inherits Branch)}

\begin{itemize}
	\item 
	\item 
	\item 
	\item 
	\item 
\end{itemize}


\section{Transformer object (Inherits Branch)}

\begin{itemize}
	\item $z\_series$
	\item $z\_shunt$
\end{itemize}











\section{element}

\begin{itemize}
	\item 
	\item 
	\item 
	\item 
	\item 
\end{itemize}


\section{Class diagram}

Here the API class diagram is sketched. All the classes are included but only the most fundamental properties and functions od each class are included to keep the diagram simple.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\linewidth]{ClassDiagram.eps}
	\caption{Simplified class diagram of GridCal's API}
	\label{fig:ClassDiagram}
\end{figure}

%----------------------------------------------------------------------------------------
%	CHAPTER 3
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % Chapter heading image
\chapter{Models}



\section{Building the admittance matrices}

This operation occurs in the \verb|Compile()| function of the \verb|Circuit| object. This function compiles many other magnitudes and among them, the following matrices:

\begin{itemize}
	\item \verb|Ybus|: Complete admittance matrix.
	
	It is a sparse matrix of size $n \times n$
	
	\item \verb|Yseries|: Admittance matrix of the series elements. It contains no value comming from shunt elements or the shunt parts of the branch model.
	
	It is a sparse matrix of size $n \times n$
	
	\item \verb|Yshunt|: Admittance vector of the shunt elements and the shunt parts of the branch model. 
	
	It is a vector of size $n$
	
	\item \verb|Yf|: Admittance matrix of the banches with their \textit{from} bus.
	
	It is a sparse matrix of size $m \times n$
	 
	\item \verb|Yt|: Admittance matrix of the banches with their \textit{to} bus.
	
	It is a sparse matrix of size $m \times n$\newline
\end{itemize}

Where $n$ is the number of buses and $m$ is the number of branches.

The relation between the admittance matrix and the series and shunt admittance matrices is the following:
\begin{equation}
Y_{bus} = Y_{series} + Y_{shunt}
\end{equation}

The algorithmic logic to build the matrices in pseudo code is the following:

\begin{verbatim}
n = number of buses in the circuit
m = number of branches in the circuit
For i=0 to n:
   bus_shunt_admittance, bus_current, bus_power, bus_voltage = buses[i].get_YISV()
   
   Yshunt[i] = bus_shunt_admittance
end

For i=0 to m:
   f = get_bus_inde(branches[i].bus_from)
   t = get_bus_inde(branches[i].bus_to)
   
   // the matrices are modified by the branch object itself
   branches[i].apply_to(Ybus,Yseries,Yshunt,Yf,Yt,i,f,t)
end
	
\end{verbatim}

\section{The universal branch model}

The following describes the model that is applied to each type of admittance matrix in the \verb|apply_to()| function inside the \verb|Branch| object seen before.

The model implemented to describe the behavior of the transformers and lines is the $\pi$ (pi) model.
\begin{figure}[h]
	\centering\includegraphics[width=0.8\linewidth]{pi-trafo.eps}
	\caption{$\pi$ model of a branch}
	\label{trafo pi model}
\end{figure}

To define the $\pi$ branch model we need to specify the following magnitudes:

\begin{itemize}
	\item $z_{series}$: Magnetizing impedance or simply series impedance. It is given in p.u.
	\item $y_{shunt}$: Leakage impedance or simply shunt impedance. It is given in p.u.
	\item $tap\_module$: Module of the tap changer. It is a magnitude around 1.
	\item $tap\_angle$: Angle of the tap changer. Angle in radians.\newline
\end{itemize}


%tap = self.tap_module * exp(-1j * self.angle)

In order to apply the effect of a branch to the admittance matrices, first we compute the complex tap value.
$$tap = tap\_module \cdot e^{-j \cdot tap\_angle}$$  

Then we compose the equivalent series and shunt admittance values of the branch. Both values are complex.
%Ys = 1 / self.z_series
$$Y_s = \frac{1}{z_{series}}$$
%Ysh = self.y_shunt / 2
$$Y_{sh} = \frac{y_{shunt}}{2}$$

\begin{itemize}
	\item $z_{series}$: Series impedance of the branch composed by the line resistance and its inductance. $z_{series}=r + jl$
	
	\item $y_{shunt}$: Shunt admittance of the line composed by the conductance and the susceptance. $y_{shunt}=c+jb$\newline
\end{itemize}



The general branch model is represented by a $2 \times 2$ matrix.
$
Y_{branch}=\left( \begin{array}{ccc}
Y_{ff} & Y_{ft} \\
Y_{tf} & Y_{tt} \end{array} \right)
$

In this matrix, the elements are the following:

%Yff = Ytt / (tap * conj(tap))
%Yft = - Ys / conj(tap)
%Ytf = - Ys / tap
%Ytt = Ys + Ysh

$$Y_{ff} = \frac{Y_s + Y_{sh}}{tap \cdot conj(tap)}  $$
$$Y_{ft} = - Y_s / conj(tap)$$
$$Y_{tf} = - Y_s / tap$$
$$Y_{tt} = Y_s + Y_{sh}$$

\subsubsection{Ybus}

The branch admittance values are applied to the complete admittance matrix as follows:

%Ybus[f, f] += Yff
%Ybus[f, t] += Yft
%Ybus[t, f] += Ytf
%Ybus[t, t] += Ytt
$${Y_{bus}}_{f, f} = {Y_{bus}}_{f, f}  + Y_{ff}$$
$${Y_{bus}}_{f, t} = {Y_{bus}}_{f, t} + Y_{ft}$$
$${Y_{bus}}_{t, f} = {Y_{bus}}_{t, f} + Y_{tf}$$
$${Y_{bus}}_{t, t} = {Y_{bus}}_{t, t} + Y_{tt}$$


These formulas assume that there might be something already in $Y_{bus}$, therefore the right way to modify these values is to add the own branch values.


\subsection{Yshunt}
%Yff_sh = Ysh
%Ytt_sh = Yff_sh / (tap * conj(tap))
%Yshunt[f] += Yff_sh
%Yshunt[t] += Ytt_sh
$${Y_{shunt}}_f = {Y_{shunt}}_f  + Y_{sh}$$
$${Y_{shunt}}_t = {Y_{shunt}}_t  + \frac{Y_{sh}}{tap \cdot conj(tap)}$$

\subsection{Yseries}
%Yseries[f, f] += Ys / (tap * conj(tap))
%Yseries[f, t] += Yft
%Yseries[t, f] += Ytf
%Yseries[t, t] += Ys

$${Y_{series}}_{f, f} = {Y_{series}}_{f, f}  + \frac{Y_{s}}{tap \cdot conj(tap)}$$
$${Y_{series}}_{f, t} = {Y_{series}}_{f, t} + Y_{ft}$$
$${Y_{series}}_{t, f} = {Y_{series}}_{t, f} + Y_{tf}$$
$${Y_{series}}_{t, t} = {Y_{series}}_{t, t} + Y_{s}$$

\subsection{Yf and Yt}
%# Yf = csr_matrix((r_[Yff, Yft], (i, r_[f, t])), (nl, nb))
%# Yt = csr_matrix((r_[Ytf, Ytt], (i, r_[f, t])), (nl, nb))

%Yf[i, f] += Yff  # Ybus[f, f]
%Yf[i, t] += Yft  # Ybus[f, t]
$${Y_f}_{i, f} = {Y_f}_{i, f} + Y_{ff}$$
$${Y_f}_{i, t} = {Y_f}_{i, t} + Y_{ft}$$

%Yt[i, f] += Ytf  # Ybus[t, f]
%Yt[i, t] += Ytt  # Ybus[t, t]
$${Y_t}_{i, f} = {Y_t}_{i, f} + Y_{tf}$$
$${Y_t}_{i, t} = {Y_t}_{i, t} + Y_{tt}$$


\section{The transformer definition from the short circuit test values}

The transformers are modeled as $\pi$ branches too. In order to get the series impedance and shunt admittance of the transformer to match the branch model, it is advised to transform the specification sheet values of the device into the desired values. The values to take from the specs sheet are:
\begin{itemize}
	\item $S_n$: Nominal power in MVA.
	\item $U_{hv}$: Voltage at the high-voltage side in kV.
	\item $U_{lv}$: Voltage at the low-voltage side in kV.
	\item $U_{sc}$: Short circuit voltage in \%.
	\item $P_{cu}$: Copper losses in kW.
	\item $I_0$: No load current in \%.
	\item $GX_{hv1}$: Reactance contribution to the HV side. Value from 0 to 1.
	\item $GR_{hv1}$: Resistance contribution to the HV side Value from 0 to 1.\newline
\end{itemize}

Then, the series and shunt impedances are computed as follows:

Nominal impedance HV (Ohm): $Zn_{hv} = U_{hv}^2 / S_n$ \newline


Nominal impedance LV (Ohm): $Zn_{lv} = U_{lv}^2 / S_n$ \newline


Short circuit impedance (p.u.): $z_{sc} = U_{sc} / 100$\newline

Short circuit resistance (p.u.): $r_{sc} = \frac{P_{cu} / 1000}{S_n}$\newline

Short circuit reactance (p.u.): $x_{sc} = \sqrt{z_{sc}^2 - r_{sc} ^2}$\newline


HV resistance (p.u.): $r_{cu,hv} = r_{sc} \cdot GR_{hv1}$\newline


LV resistance (p.u.): $r_{cu,lv} = r_{sc} \cdot (1 - GR_{hv1})$\newline


HV shunt reactance (p.u.): $xs_{hv} = x_{sc} \cdot GX_{hv1}$\newline


LV shunt reactance (p.u.): $xs_{lv} = x_{sc} \cdot (1 - GX_{hv1})$\newline

Shunt resistance (p.u.): $r_{fe} = \frac{Sn}{P_{fe} / 1000}$\newline


Magnetization impedance (p.u.): $z_m = \frac{1}{I_0 / 100}$\newline

Magnetization reactance (p.u.): $x_m = \frac{1}{\sqrt{\frac{1}{z_m^2} - \frac{1}{r_{fe}^2}}}$ \newline

If the content of the square root is negative, set the magnetization impedance to zero.\\


The final complex calculated parameters in per unit are:

Magnetizing impedance (or series impedance): $z_{series} = Z_m = r_{fe} +j \cdot x_m$

Leakage impedance (or shunt impedance): $Z_l = r_{sc} + j \cdot x_{sc}$

Shunt admittance: $y_{shunt} = 1 / Z_l$

%----------------------------------------------------------------------------------------
%	CHAPTER 4
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % Chapter heading image
\chapter{Power flow methods}

\section{Newton-Raphson-Iwamoto}

The Newton-Raphson method is the standard power flow method tough at schools. GridCal implements a slight but important modification of this method that turns it into a more robust, industry-standard algorithm. The Newton Raphson method is the first order Taylor approximation of the power flow equation. The method implemented in GridCal is the second order approximation, let's see how.

The expression to update the voltage solution in the Newton-Raphson algorithm is the following:
\begin{equation}
\textbf{V}_{i+1} = \textbf{V}_i + \textbf{J}^{-1}(\textbf{S}_0 - \textbf{S}_{calc})
\end{equation}

Where:
\begin{itemize}
	\item $\textbf{V}_i$: Voltage vector at the iteration $i$  (current voltage) 
	\item $\textbf{V}_{i+1}$: Voltage vector at the iteration $i+1$  (new voltage)
	\item $\textbf{J}$: Jacobian matrix.
	\item $\textbf{S}_0$: Specified power vector.
	\item $\textbf{S}_{calc}$: Calculated power vector using $V_i$.
\end{itemize}

The version implemented in GridCal is the following:

\begin{equation}
\textbf{V}_{i+1} = \textbf{V}_i + \mu \textbf{J}^{-1}(\textbf{S}_0 - \textbf{S}_{calc})
\end{equation}

Here $\mu$ is the Iwamoto optimal step size parameter. In 1982 S.Iwamoto and Y.Tamura present a method \cite{iwamoto1981load} where the Jacobian matrix $J$ is only computed at the beginning, and the iteration control parameter $\mu$ is computed on every iteration. In GridCal I compute $J$ and $\mu$ on every iteration getting a more robust method on the expense of a greater computational effort.

To compute the parameter $\mu$ we must do the following:

\begin{theorem}[Computation of $\mu$]
$$\textbf{J'} = Jacobian(\textbf{Y}, \textbf{dV})$$
$$\textbf{dx} = \textbf{J}^{-1}(\textbf{S}_0 - \textbf{S}_{calc})$$
$$\textbf{a} = \textbf{S}_0 - \textbf{S}_{calc}$$
$$\textbf{b} = \textbf{J} \times \textbf{dx}$$
$$\textbf{c} = \frac{1}{2} \textbf{dx} \cdot (\textbf{J'} \times \textbf{dx})$$

$$g_0 = -\textbf{a} \cdot \textbf{b}$$
$$g_1 = \textbf{b} \cdot \textbf{b} + 2  \textbf{a} \cdot \textbf{c}$$
$$g_2 = -3  \textbf{b} \cdot \textbf{c}$$
$$g_3 = 2  \textbf{c} \cdot \textbf{c}$$

$$G(x) = g_0 + g_1x + g_2x^2 + g_3x^3$$

$$\mu = solve(G(x), x_0=1)$$
\end{theorem}


There will be three solutions to the polynomial $G(x)$. Only the last solution will be real, and therefore it is the only valid value for $\mu$.
The polynomial can be solved numerically using $1$ as the seed.

The matrix $\textbf{J'}$ is the Jacobian matrix computed using the voltage derivative numerically computed as the voltage increment $\textbf{dV}= \textbf{V}_{i} - \textbf{V}_{i-1}$.  

\newpage
\section{Holomorphic Embedding (ASU)}

First introduced by Antonio Trias in 2012 \cite{TriasHELM}, promises to be a non-divergent power flow method. Trias originally developed a version with no voltage controlled nodes (PV), in which the convergence properties are excellent (With this software try to solve any grid without PV nodes to check this affirmation). 

The version programmed in the file \verb|HelmVect.py| has been adapted from the master thesis of Muthu Kumar Subramanian at the Arizona State University (ASU) \cite{subramanian2014application}. This version includes a formulation of the voltage controlled nodes. My experience indicates that the introduction of the PV control deteriorates the convergence properties of the holomorphic embedding method. However, in many cases, it is the best approximation to a solution. especially when Newton-Raphson does not provide one.

The \verb|HelmVect.py|  file contains a vectorized version of the algorithm. This means that the execution in python is much faster than a previous version that uses loops.

\subsection{Concepts}

All the power flow algorithms until the HELM method was introduced were iterative and recursive. The helm method is iterative but not recursive. A simple way to think of this is that traditional power flow methods are exploratory, while the HELM method is a planned journey. In theory the HELM method is superior, but in practice the numerical degeneration makes it less ideal.

The fundamental idea of the recursive algorithms is that given a voltage initial point (1 p.u. at every node, usually) the algorithm explores the surroundings of the initial point until a suitable voltage solution is reached or no solution at all is found because the initial point is supposed to be "far" from the solution.

On the HELM methods, we form a "curve" that departures from a known mathematically exact solution that is obtained from solving the grid with no power injections. This is possible because with no power injections, the grid equations become linear and straight forward to solve. The arriving point of the "curve" is the solution that we want to achieve. That "curve" is best approximated by a Padè approximation. To compute the Padè approximation we need to compute coefficient of the unknown variables, in our case the voltage (and possibly the reactive power).

The HELM formulation consists in the derivation of formulas that enable the calculation of the coefficients of the series that describes the "curve" from the mathematically know solution to the unknown solution. Once the coefficients are obtained, the Padè approximation computes the voltage solution at the "end of the curve", providing the desired voltage solution. The more coefficients we compute the more exact the solution is (this is true until the numerical precision limit is reached).\newline 


All this sounds very strange, but it works ;)\newline 


If you want to get familiar with this concept, you should read about the homotopy concept. In practice the continuation power flow does the same as the HELM algorithm, it takes a known solution and changes the loading factors until a solution for another state is reached.

\subsection{Fundamentals}

The fundamental equation that defines the power flow problem is:
\begin{equation}
S = V \times (Y \times V)^*
\end{equation}

Most usefully represented like this:


\begin{equation}
{\textbf{Y} \times \textbf{V}} = \left(\frac{\textbf{S}}{\textbf{V}}\right)^* 
\label{base_eq}
\end{equation}


The holomorphic embedding is to insert a "travelling" parameter $\alpha$, such that for $\alpha=0$ we have an mathematically exact solution of the problem (but not the solution we're looking for...), and for $\alpha=1$ we have the solution we're looking for. The other thing to do is to represent the variables to be computes as McLaurin series. We'll go step by step.\newline

For $\alpha=0$ we say that $S=0$, in this way the equation \ref{base_eq} becomes linear, and its solution is mathematically exact. But for that to be useful in our case we need to split the admittance matrix $Y$ into $Y_{series}$ and $Y_{shunt}$. $Y_{shunt}$ is a diagonal matrix, so it can be expressed as a vector instead (no need for matrix-vector product).

\begin{equation}
\textbf{Y}_{series} \times \textbf{V} = \left(\frac{\textbf{S}}{\textbf{V}}\right)^* - \textbf{Y}_{shunt} \textbf{V}
\label{base_eq_alpha_0}
\end{equation}

This is what will allow us to find the zero "state" in the holomorphic series calculation. For $\alpha=1$ we say that $S=S$, so we don't know the voltage solution, however we can determine a path to get there:

\begin{equation}
{\textbf{Y }\times \textbf{V}( \alpha )} = \left(\frac{ \alpha\textbf{S}}{\textbf{V}( \alpha )}\right)^* - \alpha \textbf{Y}_{shunt} \times \textbf{V}( \alpha ) = \frac{ \alpha\textbf{S}^*}{\textbf{V}( \alpha )^*} - \alpha \textbf{Y}_{shunt} \textbf{V}( \alpha )
\label{base_eq_embedded}
\end{equation}

Wait, what?? did you just made this stuff up??, well so far my reasoning is:
\begin{itemize}
	\item The voltage ($V$) is what I have to convert into a series, and the series depend of $\alpha$, so it makes sense to say that $V$ is now $V(\alpha)$.
	
	\item Regarding the $\alpha$ that multiplies the $S$, the power ($S$) is what I vary during the \textit{travel} from $\alpha=0$ to $\alpha=1$, so that is why it has to be accompanied by the \textit{traveling} parameter $\alpha.$
	
	\item In my opinion the $\alpha$ $\textbf{Y}_{shunt}$ is to provoke the first voltage coefficients to be one.  $\textbf{Y}_{series} \times \textbf{V}[0] = 0$, makes $V[0]=1$, and this is essential for later steps (to be able to use Padè). \newline
\end{itemize}

The series are expressed as McLaurin equations::

\begin{equation}
V(\alpha) = \sum_{n}^{\infty} V_n \alpha ^n
\label{eq:McLaurinV}
\end{equation}

\begin{theorem}[Holomorphicity check]

There's still something to do. The magnitude $\left(\textbf{V}( \alpha )\right)^*$ has to be converted into $\left(\textbf{V}( \alpha^* )\right)^*$. This is done in order to make the function be actually holomorphic. The holomorphicity condition is tested by the Cauchy-Riemann condition, this is $\partial V / \partial \alpha^* = 0$, let's check that:

\begin{equation}
\partial \left(\textbf{V}( \alpha )^*\right) / \partial \alpha^*  = \partial \left(\sum_{n}^{\infty} V_n^* (\alpha ^n)^*\right) / \partial \alpha^*  = \sum_{n}^{\infty} \alpha ^n V_n^* (\alpha ^{n-1})^*
\end{equation} 
Which is not zero, obviously. Now with the proposed change:

\begin{equation}
\partial \left( \textbf{V}( \alpha^* )\right)^* / \partial \alpha^*  = \partial \left(\sum_{n}^{\infty} \textbf{V}_n^* \alpha ^n \right) / \partial \alpha^*  = 0
\end{equation} 

Yay!, now we're mathematically happy, since this stuff has no effect in practice because our $\alpha$ is not going to be a complex parameter, but for sake of being correct the equation is now:

\begin{equation}
{\textbf{Y}_{series}\times \textbf{V}( \alpha )} = \frac{ \alpha\textbf{S}^*}{\textbf{V}^*( \alpha^* )} - \alpha \textbf{Y}_{shunt} \textbf{V}( \alpha )
\label{base_eq_embedded2}
\end{equation}

\end{theorem}


The fact that $\textbf{V}^*( \alpha^* )$ is dividing is problematic. We need to express it as its inverse so it multiplies instead of divide.

\begin{equation} 
\frac{1}{\textbf{V}( \alpha)} = \textbf{W}( \alpha ) \longrightarrow \textbf{W}( \alpha ) \textbf{V}( \alpha) = 1 \longrightarrow \sum_{n=0}^{\infty}{\textbf{W}_n \alpha^n}  \sum_{n=0}^{\infty}{\textbf{V}_n \alpha^n} = 1
\end{equation}

Expanding the series and identifying terms of $\alpha$ we obtain the expression to compute the inverse voltage series coefficients:

\begin{equation}
\textbf{W}_n =
\left\{
	\begin{array}{ll}
		\mathlarger{\frac{1}{\textbf{V}_0}}, \quad n=0\\
		\mathlarger{\frac{\mathlarger{\sum_{k=0}^{n-1}\textbf{W}_k \textbf{V}_{n-k}}}{\textbf{V}_0}}, \quad n>0
	\end{array}
\right.
\end{equation}


Now, the equation \ref{base_eq_embedded2} is:

\begin{equation}
{\textbf{Y}_{series}\times \textbf{V}( \alpha )} = \alpha\textbf{S}^* \textbf{W}( \alpha)^*  - \alpha \textbf{Y}_{shunt} \textbf{V}( \alpha )
\label{base_eq_embedded3}
\end{equation}

Substituting the series by their McLaurin expressions:

\begin{equation}
{\textbf{Y}_{series}\times \sum_{n=0}^{\infty}{\textbf{V}_n \alpha^n}} = \alpha\textbf{S}^* \left(\sum_{n=0}^{\infty}{\textbf{W}_n \alpha^n}\right)^*  - \alpha \textbf{Y}_{shunt} \sum_{n=0}^{\infty}{\textbf{V}_n \alpha^n}
\label{base_eq_embedded4}
\end{equation}

Expanding the series an identifying terms of $\alpha$ we obtain the expression for the voltage coefficients:

\begin{equation}
\textbf{V}_n =
\left\{
	\begin{array}{ll}
		\mathlarger{0}, \quad n=0\\
		\mathlarger{\textbf{S}^* \textbf{W}^*_{n-1} - Y_{shunt} \textbf{V}_{n-1} }, \quad n>0
	\end{array}
\right.
\end{equation}

This is the HELM fundamental formula derivation for a grid with no voltage controlled nodes (no PV nodes). Once a sufficient number of coefficients are obtained, we still need to use the Padè approximation to get voltage values out of the series.


In the previous formulas, the number of the bus has not been explicitly detailed. All the $\textbf{V}$ and the $\textbf{W}$ are matrices of dimension $n \times nbus$ (number of coefficients by number of buses in the grid) This structures are depicted in the figure \ref{fig:CoefficientsStructure}.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{CoefficientsStructure.eps}
	\caption{Structure of the coefficients}
	\label{fig:CoefficientsStructure}
\end{figure}

\subsection{Padè approximation}

The equation \ref{eq:McLaurinV} provides us an expression to obtain the voltage from the coefficients, knowing that $\alpha$ should be $1$ to get the final voltage results. So, why do we need any further operation?, and what is this Padè thing?

Well, it is true that the equation \ref{eq:McLaurinV} provides an approximation of the voltage by means of a series (this is similar to a Taylor approximation), but in practice, the approximation might provide a wrong value for a given number of coefficients. The Padè approximation accelerates the convergence of any given series, so that you get a more accurate result with less coefficients. This means that for the same series of voltage coefficients, using the equation \ref{eq:McLaurinV} could give a completely wrong result, whereas by applying Padè you could obtain a fairly accurate result.

The Padè approximation is a rational approximation of a function (the voltage series in our case). The approximation is valid over a small domain of the function, in our case the domain is $\alpha=[0,1]$. The method requires the function to be continuous and differentiable for $\alpha=0$. Hence the Cauchy-Riemann condition (yes, our function meets this condition, we tested it before).

GridCal implements two algorithms that perform the Padè approximation; The Padè canonical algorithm, and Wynn's Padè approximation.

\subsubsection{Padè approximation algorithm}

The canonical Padè algorithm for our problem is described by:

\begin{equation}
Voltage\_value\_approximation = \frac{P_N(\alpha)}{Q_M(\alpha)} \quad \forall \alpha \in [0,1]
\label{eq:pade_apprx}
\end{equation}

Here $N=M=n/2$, where $n$ is the number of available voltage coefficients, which has to be an even number to be exactly divisible by $2$.

\begin{equation}
P_N(\alpha) = p_0 + p_1\alpha + p_2\alpha^2 + ... + p_N\alpha^N
\end{equation}

\begin{equation}
Q_M(\alpha) = 1 + q_1\alpha + q_2\alpha^2 + ... + q_M\alpha^M
\end{equation}

It turns out that if we make the first term of $Q_M(\alpha)$ be $q_0=1$, the function to be approximated is given by the McLaurin expression (What a happy coincidence!)

The problem now boils down to find the $q_i$ and $p_i$ coefficients. This is done by solving two systems of equations. The first one to find $q_i$ which does not depend on $p_i$, and the second one to get $p_i$ which does depend on $q_i$.

First system: The only unknowns are the $q_i$.

\begin{equation}
\begin{matrix}
q_M V_{N-M+1} + q_{M-1}V_{N-M+2}+...+q_1V_N = 0\\
q_M V_{N-M+2} + q_{M-1}V_{N-M+3}+...+q_1V_{N+1} = 0\\
...\\
q_M V_{N} + q_{M-1}V_{N+1}+...+q_1V_{N+M+1} + V_{N+M} = 0\\
\end{matrix}
\end{equation}

Second System: The only unknowns are the $p_i$.
\begin{equation}
\begin{matrix}
V_0 - p_0=0\\
q_1V_0 + V_1  p_1=0\\
q_2V_0 + q_1V_1+V_2-p_2=0\\
q_3V_0 + q_2V_1 + q_1V_2 + V_3 - p_3 = 0\\
...\\
q_MV_{N-M} + q_{M-1}V_{N-M+1} + ... + +V_N - p_N=0
\end{matrix}
\end{equation}

Once the coefficients are there, you would have defined completely the polynomials $P_N(\alpha)$ and $Q_M(\alpha)$, and it is only a matter of evaluating the equation \ref{eq:pade_apprx} for $\alpha=1$.\newline


This process is done for every column of coefficients $\textbf{V}=\{V_0, V_1,V_2,V_3, ...,V_n\}$ of the structure depicted in the figure \ref{fig:CoefficientsStructure}, obtaining the voltage value for every bus.

\subsubsection{Wynn's Padè approximation algorithm}

Wynn published a paper in 1969 where he proposed a simple calculation method to obtain the Padè approximation. This method is based on a table. Weniger in 1989 publishes his thesis where a faster version of Wynn's algorithm is provided in Fortran code. 

That very Fortran piece of code has been translated into Python and included in GridCal.

One of the advantages of this method over the canonical Padè approximation implementation is that it can be used for every iteration. In the beginning I thought it would be faster but it turns out that it is not faster since the amount of computation increases with the number of coefficients, whereas with the canonical implementation the order of the matrices does not grow dramatically and it is executed the half of the times.

On top of that my experience shows that the canonical implementation provides a more consistent convergence.

Anyway, both implementations are there to be used in the code.


\subsection{PV nodes formulation}

%----------------------------------------------------------------------------------------
%	CHAPTER 4
%----------------------------------------------------------------------------------------

\chapterimage{chapterhdr1.jpg} % Chapter heading image
\chapter{Graphical User Interface}

% ----------------------------------------------------------------------------------------
% 	BIBLIOGRAPHY
% ----------------------------------------------------------------------------------------
%\chapter*{Bibliography}
\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}